## プロトコルスイート
```
fed
HTTP
TLS
TCP
```

## データのフォーマット
fedで扱われる各種オブジェクトはJSON形式で配信される。

## サーバー
サーバーは1つ以上のサービスを持つ。
サーバー間でメッセージのやり取りを行うために、他のサーバーとセッションを確立する。

エンドポイント`/server`にGETリクエストを送信することで、サーバーのメタデータを取得できる。

メタデータの構造:
```ts
interface Metadata {
  services: {
    descriptorUrl: string;
  }[]
}
```
各サービスのdescriptorUrlフィールドには、サービス記述子が配信されているURLを指定する。

## サービス
サービスは標準的なものについては随時定義される。
定義されていないサービスは独自に定義することができる。

サービスを定義するには、サービス記述子を作成する。
サービス記述子では、やり取りされるメッセージの構造を定義できる。

各メッセージのschemaUrlフィールドには、メッセージのスキーマが配信されているURLを指定する。
各メッセージはJSON Schemaでスキーマ定義される。

サービス記述子の構造:
```ts
interface ServiceDescriptor {
  id: string;
  baseServiceUrl?: string;
  messages: {
    schemaUrl: string;
  }[];
}
```

サービスは、オブジェクト指向言語にあるような継承の仕組みを持つ。
継承元のサービスを「基本サービス」と呼び、継承先のサービスを「派生サービス」と呼ぶ。

派生サービスは、基本サービスの上位互換を持つ。
派生サービスを実装するサーバーは、基本サービスとしてもメッセージをやり取りできる。

## メッセージ

### メッセージの検証
メッセージの内容は、スキーマ定義を用いて受信側のサーバーで検証されるべきである。

### リソース
メッセージに関係する画像や動画などのリソースは、メッセージの中ではURLによって表現される。

また、リソース自体はHTTPに従って配信される。
具体的なHTTPの仕様(バージョン等)については、この仕様では規定しない。

### メッセージの転送
メッセージは、エンドポイント`/server/port`で受け渡される。

## セッション
2つのサーバーの間で、セッションを確立することによりサーバー間でメッセージをやり取りできるようになる。
セッションの確立手順にはネゴシエーションが含まれる。

サーバーは、サービス構成に変更があった場合に、保持しているセッションを全て破棄する。

### メッセージを送信する時
サーバーは以下の手順でメッセージの送信を試行する：
- 相手サーバーとのセッションがない場合またはセッションが無効な場合は、送信を保留し相手サーバーとのセッションを確立する。
- セッションの確立に失敗した、または相手サーバーがそのサービスを提供していない場合は、送信をキャンセルする。
- 相手サーバーにメッセージを送信する。

### メッセージを受信した時
サーバーはメッセージを受信した際に、相手サーバーとのセッションが有効かどうかを判定する。
無効な場合はサーバーは通信を拒否しセッションが無効であることを相手サーバーに通知する。

### ネゴシエーション
サーバーは、相手サーバーのメタデータを取得し、両者が共通して持っているサービスを列挙する。
これにより、連合可能なサービスを認識し、お互いのサーバーが通信可能かどうかを判断する。

## サーバーの識別・認証
未定。
- HTTP Signatureを使う？
- ホスト名をサーバーの認識に使用しない
